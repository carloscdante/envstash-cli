// src/libsql.ts
import { Debug as Debug2, err, ok } from "@prisma/driver-adapter-utils";
import { Mutex } from "async-mutex";

// src/conversion.ts
import { ColumnTypeEnum, Debug } from "@prisma/driver-adapter-utils";
var debug = Debug("prisma:driver-adapter:libsql:conversion");
function mapDeclType(declType) {
  switch (declType.toUpperCase()) {
    case "":
      return null;
    case "DECIMAL":
      return ColumnTypeEnum.Numeric;
    case "FLOAT":
      return ColumnTypeEnum.Float;
    case "DOUBLE":
    case "DOUBLE PRECISION":
    case "NUMERIC":
    case "REAL":
      return ColumnTypeEnum.Double;
    case "TINYINT":
    case "SMALLINT":
    case "MEDIUMINT":
    case "INT":
    case "INTEGER":
    case "SERIAL":
    case "INT2":
      return ColumnTypeEnum.Int32;
    case "BIGINT":
    case "UNSIGNED BIG INT":
    case "INT8":
      return ColumnTypeEnum.Int64;
    case "DATETIME":
    case "TIMESTAMP":
      return ColumnTypeEnum.DateTime;
    case "TIME":
      return ColumnTypeEnum.Time;
    case "DATE":
      return ColumnTypeEnum.Date;
    case "TEXT":
    case "CLOB":
    case "CHARACTER":
    case "VARCHAR":
    case "VARYING CHARACTER":
    case "NCHAR":
    case "NATIVE CHARACTER":
    case "NVARCHAR":
      return ColumnTypeEnum.Text;
    case "BLOB":
      return ColumnTypeEnum.Bytes;
    case "BOOLEAN":
      return ColumnTypeEnum.Boolean;
    default:
      debug("unknown decltype:", declType);
      return null;
  }
}
function mapDeclaredColumnTypes(columntTypes) {
  const emptyIndices = /* @__PURE__ */ new Set();
  const result = columntTypes.map((typeName, index) => {
    const mappedType = mapDeclType(typeName);
    if (mappedType === null) {
      emptyIndices.add(index);
    }
    return mappedType;
  });
  return [result, emptyIndices];
}
function getColumnTypes(declaredTypes, rows) {
  const [columnTypes, emptyIndices] = mapDeclaredColumnTypes(declaredTypes);
  if (emptyIndices.size === 0) {
    return columnTypes;
  }
  columnLoop:
    for (const columnIndex of emptyIndices) {
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        const candidateValue = rows[rowIndex][columnIndex];
        if (candidateValue !== null) {
          columnTypes[columnIndex] = inferColumnType(candidateValue);
          continue columnLoop;
        }
      }
      columnTypes[columnIndex] = ColumnTypeEnum.Int32;
    }
  return columnTypes;
}
function inferColumnType(value) {
  switch (typeof value) {
    case "string":
      return ColumnTypeEnum.Text;
    case "bigint":
      return ColumnTypeEnum.Int64;
    case "boolean":
      return ColumnTypeEnum.Boolean;
    case "number":
      return ColumnTypeEnum.UnknownNumber;
    case "object":
      return inferObjectType(value);
    default:
      throw new UnexpectedTypeError(value);
  }
}
function inferObjectType(value) {
  if (value instanceof ArrayBuffer) {
    return ColumnTypeEnum.Bytes;
  }
  throw new UnexpectedTypeError(value);
}
var UnexpectedTypeError = class extends Error {
  constructor(value) {
    const type = typeof value;
    const repr = type === "object" ? JSON.stringify(value) : String(value);
    super(`unexpected value of type ${type}: ${repr}`);
    this.name = "UnexpectedTypeError";
  }
};
function mapRow(row, columnTypes) {
  const result = Array.from(row);
  for (let i = 0; i < result.length; i++) {
    const value = result[i];
    if (value instanceof ArrayBuffer) {
      result[i] = Array.from(new Uint8Array(value));
      continue;
    }
    if (typeof value === "number" && (columnTypes[i] === ColumnTypeEnum.Int32 || columnTypes[i] === ColumnTypeEnum.Int64) && !Number.isInteger(value)) {
      result[i] = Math.trunc(value);
      continue;
    }
    if (["number", "bigint"].includes(typeof value) && columnTypes[i] === ColumnTypeEnum.DateTime) {
      result[i] = new Date(Number(value)).toISOString();
      continue;
    }
    if (typeof value === "bigint") {
      result[i] = value.toString();
      continue;
    }
  }
  return result;
}

// src/libsql.ts
var debug2 = Debug2("prisma:driver-adapter:libsql");
var LOCK_TAG = Symbol();
var _a;
var LibSqlQueryable = class {
  constructor(client) {
    this.client = client;
    this.provider = "sqlite";
    this[_a] = new Mutex();
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters.
   */
  async queryRaw(query) {
    const tag = "[js::query_raw]";
    debug2(`${tag} %O`, query);
    const ioResult = await this.performIO(query);
    return ioResult.map(({ columns, rows, columnTypes: declaredColumnTypes }) => {
      const columnTypes = getColumnTypes(declaredColumnTypes, rows);
      return {
        columnNames: columns,
        columnTypes,
        rows: rows.map((row) => mapRow(row, columnTypes))
      };
    });
  }
  /**
   * Execute a query given as SQL, interpolating the given parameters and
   * returning the number of affected rows.
   * Note: Queryable expects a u64, but napi.rs only supports u32.
   */
  async executeRaw(query) {
    const tag = "[js::execute_raw]";
    debug2(`${tag} %O`, query);
    return (await this.performIO(query)).map(({ rowsAffected }) => rowsAffected ?? 0);
  }
  /**
   * Run a query against the database, returning the result set.
   * Should the query fail due to a connection error, the connection is
   * marked as unhealthy.
   */
  async performIO(query) {
    const release = await this[LOCK_TAG].acquire();
    try {
      const result = await this.client.execute(query);
      return ok(result);
    } catch (e) {
      const error = e;
      debug2("Error in performIO: %O", error);
      const rawCode = error["rawCode"] ?? e.cause?.["rawCode"];
      if (typeof rawCode === "number") {
        return err({
          kind: "Sqlite",
          extendedCode: rawCode,
          message: error.message
        });
      }
      throw error;
    } finally {
      release();
    }
  }
};
_a = LOCK_TAG;
var LibSqlTransaction = class extends LibSqlQueryable {
  constructor(client, options, unlockParent) {
    super(client);
    this.options = options;
    this.unlockParent = unlockParent;
  }
  async commit() {
    debug2(`[js::commit]`);
    try {
      await this.client.commit();
    } finally {
      this.unlockParent();
    }
    return ok(void 0);
  }
  async rollback() {
    debug2(`[js::rollback]`);
    try {
      await this.client.rollback();
    } catch (error) {
      debug2("error in rollback:", error);
    } finally {
      this.unlockParent();
    }
    return ok(void 0);
  }
};
var PrismaLibSQL = class extends LibSqlQueryable {
  constructor(client) {
    super(client);
  }
  async startTransaction() {
    const options = {
      usePhantomQuery: true
    };
    const tag = "[js::startTransaction]";
    debug2(`${tag} options: %O`, options);
    const release = await this[LOCK_TAG].acquire();
    try {
      const tx = await this.client.transaction("deferred");
      return ok(new LibSqlTransaction(tx, options, release));
    } catch (e) {
      release();
      throw e;
    }
  }
};
export {
  PrismaLibSQL
};
